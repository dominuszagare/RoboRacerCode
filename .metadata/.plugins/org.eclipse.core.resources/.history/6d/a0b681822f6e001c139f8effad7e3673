/*
 * robotTasks.c
 *
 *  Created on: Jan 5, 2022
 *      Author: ddomi
 */
#include "robotTasks.h"
#include "FreeRTOS.h"
#include "task.h"
#include "robotPeriferija.h"
#include "nrf24.h"
#include "math.h"
#include "MadgwickAHRS.h"

#define PID_CONTROL 1
#define PID_P 0.8f
#define PID_P_LIMIT 1.0f
#define PID_I 0.02f
#define PID_I_LIMIT 50.0f
#define PID_D 0.1f
#define PID_LIMIT 1.0f
#define SPEEDMOD 0.5f

#define PI 3.14159265358979323846f
#define DEG_TO_RAD 0.01745329252f

extern nRF24_RXResult pipe;
extern volatile uint8_t nRF24_dataReady;
extern volatile uint8_t nRF24_status;
extern volatile int payload_length;

extern volatile uint8_t GyroReady;
extern volatile uint8_t AccReady;
extern volatile uint8_t MagReady;
extern volatile uint8_t sendData;

extern volatile uint8_t SPIcommandRecived;

extern volatile uint8_t SpiTxData[SPI_BUFFER_SIZE];
extern volatile uint8_t SpiRxData[SPI_BUFFER_SIZE];

extern volatile uint32_t timeSinceLastCommand;



float normalize_v3f(float* x, float* y, float* z){
	float norm = sqrt( (*x) * (*x) + (*y) * (*y) + (*z) * (*z) );
	*x /= norm;
	*y /= norm;
	*z /= norm;
}

int16_t zgladiMotor(enum motor m, int16_t pwm){
	switch(m){
	case LF:
		return izracunajPovprecjeInt16(&M4,pwm,5);
	case RB:
		return izracunajPovprecjeInt16(&M2,pwm,5);
	case RF:
		return izracunajPovprecjeInt16(&M1,pwm,5);
	case LB:
		return izracunajPovprecjeInt16(&M3,pwm,5);
	}
}

void speedControl(struct motorData* m, float deltaT){
	//premakni motor z zeljeno hitrostjo
	//izracunaj hitrost z tekocim povprecjem
	float vel = (float)((m->poz - m->prevPoz)/deltaT)/1000;
	m->prevPoz = m->poz;
	m->sum =  m->sum + vel - m->vals[m->index]; //pristejemo trenutno vrednost in odstejemo zadnjo
	m->vals[m->index] = vel; //na zadnjo zamenjamo z novo
	m->index++;
	if(m->index > 9){m->index = 0;}
	vel = m->sum/10; //izracunamo povprecje

	if(m->targetVel < 0.05 && m->targetVel > -0.05){
		m->targetVel = 0;
		m->integralError = 0;
	}

	if(PID_CONTROL == 1){
		m->error = (m->targetVel) - vel;
		if(m->error > PID_P_LIMIT){m->error=PID_P_LIMIT;}
		if(m->error < -PID_P_LIMIT){m->error=-PID_P_LIMIT;}

		m->integralError = m->integralError + m->error;
		if(m->integralError > PID_I_LIMIT){m->integralError = PID_I_LIMIT;}
		if(m->integralError < -PID_I_LIMIT){m->integralError = -PID_I_LIMIT;}

		float deltaE = 0.0f;
		if((m->error - m->prevError)>0.01f && (m->error - m->prevError)<-0.01f){deltaE=((m->error - m->prevError)/deltaT);}
		m->prevError = m->error;

		float power = PID_P*m->error + PID_I*m->integralError + PID_D*deltaE;
		if(power > PID_LIMIT){power = PID_LIMIT;}
		if(power < -PID_LIMIT){power = -PID_LIMIT;}
		nastaviMotor(m->num,zgladiMotor(m->num,scalePwm(power)));
	}
	else{
		int Pwm = zgladiMotor(m->num,scalePwm(m->targetVel));
		nastaviMotor(m->num,Pwm);
	}
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	//kateri pin je poklical EXIT event
	if(GPIO_Pin == GPIO_PIN_14){
		nRF24_dataReady = 1; //spremenil se je status register pejt pogledat kaj se je zgodilo
	}
	else if(GPIO_Pin == GPIO_PIN_15){
		if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_2)){motorLF.poz--;}
		else{motorLF.poz++;}
	}
	else if(GPIO_Pin == GPIO_PIN_7){
		if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_5)){motorRF.poz--;}
		else{motorRF.poz++;}
	}
	else if(GPIO_Pin == GPIO_PIN_3){
		if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_11)){motorRB.poz--;}
		else{motorRB.poz++;}
	}
	else if(GPIO_Pin == GPIO_PIN_8){
		if(HAL_GPIO_ReadPin(GPIOD,GPIO_PIN_6)){motorLB.poz--;}
		else{motorLB.poz++;}
	}
	else if(GPIO_Pin == GPIO_PIN_1){ //vsakic ko dobis interupt posodobi podatke
		spi1_beriRegistre(0x28, (uint8_t*)&Gyro, 6);
		GyroReady = 1; //zastavica da so na voljo novi podatki 200Hz
	}
	else if(GPIO_Pin == GPIO_PIN_4){
		//data ready pospeskometer
		i2c1_beriRegistre(0x19, 0x28,(uint8_t*)&Acc, 6);
		AccReady = 1; //200Hz
	}
	else if(GPIO_Pin == GPIO_PIN_2){
		//data ready megnetometer
		i2c1_beriRegistre(0x1e, 0x68,(uint8_t*)&Mag, 6);
		MagReady = 1; //100Hz
	}

}


void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi){
	SPIcommandRecived = 1;
	//HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, 1);
	HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_13); //oranzna
	//HAL_SPI_Receive_DMA(&hspi5, (uint8_t*)&rasberyReq, rasberyReqSize);
	//..rasberyReq = *(struct recivedRasberyPiPayload*)SpiRxData;
	//if( SpiRxData[0] == 22){
	//	SPIcommandRecived = 1;
	//	//HAL_SPI_Transmit(&hspi5, (uint8_t*)&P, 28, 100);
	//}
}

void StartCalculatingPoz(void *argument){
	while(1){
		HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_13);
		vTaskDelay(300);
	}
}
void StartRecivingCommandsNRF24(void *argument){
	while(1){
		HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_14);
		vTaskDelay(500);
	}
}
void StartMotorControl(void *argument){
	while(1){
	  if((HAL_GetTick() - timeSinceLastCommand)>200){
		  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, 0);
		  nastaviMotor(RF,0); motorRF.integralError = 0; motorRF.targetVel = 0;
		  nastaviMotor(LF,0); motorLF.integralError = 0; motorLF.targetVel = 0;
		  nastaviMotor(LB,0); motorLB.integralError = 0; motorLB.targetVel = 0;
		  nastaviMotor(RB,0); motorRB.integralError = 0; motorRB.targetVel = 0;
	  }
	  speedControl(&motorLB,0.01);
	  speedControl(&motorLF,0.01);
	  speedControl(&motorRB,0.01);
	  speedControl(&motorRF,0.01);
	  vTaskDelay(10);
	}
}

volatile int32_t motorRFprevPoz=0;
volatile int32_t motorLFprevPoz=0;
volatile int32_t motorRBprevPoz=0;
volatile int32_t motorLBprevPoz=0;

void StartCalculatingPath(void *argument){
	while(1){
		float pot = (float)(motorRF.poz - motorRFprevPoz);
		pot *= PI*0.003f;
		motorRFprevPoz = motorRF.poz;
		P.pozX += sin(P.heading) * pot;
		P.pozY += cos(P.heading) * pot;
		vTaskDelay(600);
	}
}
