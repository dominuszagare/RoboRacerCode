/*
 * robotTasks.c
 *
 *  Created on: Jan 5, 2022
 *      Author: ddomi
 */
#include "robotTasks.h"
#include "FreeRTOS.h"
#include "task.h"
#include "robotPeriferija.h"
#include "nrf24.h"
#include "math.h"
#include "MadgwickAHRS.h"

#define PID_CONTROL 1
#define PID_P 0.8f
#define PID_P_LIMIT 1.0f
#define PID_I 0.02f
#define PID_I_LIMIT 50.0f
#define PID_D 0.1f
#define PID_LIMIT 1.0f
#define SPEEDMOD 0.5f

#define PI 3.14159265358979323846f
#define DEG_TO_RAD 0.01745329252f


float normalize_v3f(float* x, float* y, float* z){
	float norm = sqrt( (*x) * (*x) + (*y) * (*y) + (*z) * (*z) );
	*x /= norm;
	*y /= norm;
	*z /= norm;
}

int16_t zgladiMotor(enum motor m, int16_t pwm){
	switch(m){
	case LF:
		return izracunajPovprecjeInt16(&M4,pwm,5);
	case RB:
		return izracunajPovprecjeInt16(&M2,pwm,5);
	case RF:
		return izracunajPovprecjeInt16(&M1,pwm,5);
	case LB:
		return izracunajPovprecjeInt16(&M3,pwm,5);
	}
}

void speedControl(struct motorData* m, float deltaT){
	//premakni motor z zeljeno hitrostjo
	//izracunaj hitrost z tekocim povprecjem
	float vel = (float)((m->poz - m->prevPoz)/deltaT)/1000;
	m->prevPoz = m->poz;
	m->sum =  m->sum + vel - m->vals[m->index]; //pristejemo trenutno vrednost in odstejemo zadnjo
	m->vals[m->index] = vel; //na zadnjo zamenjamo z novo
	m->index++;
	if(m->index > 9){m->index = 0;}
	vel = m->sum/10; //izracunamo povprecje

	if(m->targetVel < 0.05 && m->targetVel > -0.05){
		m->targetVel = 0;
		m->integralError = 0;
	}

	if(PID_CONTROL == 1){
		m->error = (m->targetVel) - vel;
		if(m->error > PID_P_LIMIT){m->error=PID_P_LIMIT;}
		if(m->error < -PID_P_LIMIT){m->error=-PID_P_LIMIT;}

		m->integralError = m->integralError + m->error;
		if(m->integralError > PID_I_LIMIT){m->integralError = PID_I_LIMIT;}
		if(m->integralError < -PID_I_LIMIT){m->integralError = -PID_I_LIMIT;}

		float deltaE = 0.0f;
		if((m->error - m->prevError)>0.01f && (m->error - m->prevError)<-0.01f){deltaE=((m->error - m->prevError)/deltaT);}
		m->prevError = m->error;

		float power = PID_P*m->error + PID_I*m->integralError + PID_D*deltaE;
		if(power > PID_LIMIT){power = PID_LIMIT;}
		if(power < -PID_LIMIT){power = -PID_LIMIT;}
		nastaviMotor(m->num,zgladiMotor(m->num,scalePwm(power)));
	}
	else{
		int Pwm = zgladiMotor(m->num,scalePwm(m->targetVel));
		nastaviMotor(m->num,Pwm);
	}
}

void StartCalculatingPoz(void *argument){

}
void StartRecivingCommandsNRF24(void *argument){

}
void StartMotorControl(void *argument){

}
void StartCalculatingPath(void *argument){

}
